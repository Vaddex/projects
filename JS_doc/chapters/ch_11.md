# HTTP-запити і взаємодія з бекендом

###### [to main page](../js_main.md)

## Інтернет і протоколи

### Протокол HTTP

Перед тим як користувач побачить вміст сайту на екрані, браузер робить запит на
сервер, щоб отримати цей вміст. HTML-файл, зображення, стилі та скрипти — усе це
приходить із сервера за HTTP протоколом. HTTP протокол, по суті, є набором
правил і домовленостей, що використовуються при передачі даних у мережі.

![protocolHttp](./img/11_ch/1.jpg)

**HyperText Transfer Protocol (протокол передачі гіпертексту)** — поширений
протокол для передачі вебресурсів різних типів: html, css, javascript,
зображень, аудіо та відео тощо.

HTTP ґрунтується на структурі **клієнт-сервер** і моделі **запит-відповідь**.

Як це працює?

1. Клієнтський застосунок ініціює з'єднання, формує запит і відправляє його на
   сервер.
2. Після чого сервер обробляє цей запит, формує відповідь і передає її назад
   клієнтові.
3. Зв'язок між ними здійснюється за допомогою низки перемежованих HTTP-запитів і
   HTTP-відповідей.

![request](./img/11_ch/2.jpg)

Запит відбувається в кілька етапів:

-   **DNS-запит** — пошук найближчого DNS-сервера, щоб перетворити адресу
    (наприклад `google.com`) в її числове вираження, IP-адресу (74.125.87.99).
-   `З'єднання` — встановлення з'єднання з сервером за отриманою IP-адресою.
-   `Передача даних` — пересилання пакетів з клієнта на сервер.
-   `Очікування відповіді` — очікування, доки пакети даних дійдуть до сервера,
    він їх обробить, і відповідь повернеться назад до клієнта.
-   `Отримання даних` — пакети надійшли, можна отримувати з них дані.

### Протокол HTTPS

**HyperText Transfer Protocol Secure** — це налаштування над протоколом HTTP, у
якому всі повідомлення між клієнтом і сервером шифруються з метою підвищення
безпеки.

HTTPS протокол забезпечує захист від атак, що базуються на “прослуховуванні”
з'єднання. Дані передаються з використанням криптографічних протоколів SSL або
TLS.

![connection](./img/11_ch/3.jpg)

Під час обміну через звичайне HTTP-з'єднання всі дані передаються у вигляді
тексту і можуть бути прочитані всіма, хто отримав доступ до з'єднання між
клієнтом і сервером. Якщо користувачі роблять покупки онлайн і заповнюють форму
замовлення, що містить інформацію про кредитну картку, їхні фінансові дані
набагато легше викрасти, якщо вони передаються у вигляді тексту. З HTTPS дані
будуть зашифровані і хакер не зможе їх розшифрувати, тому що для розшифрування
необхідний доступ до закритого ключа, який зберігається на сервері.

Протокол HTTPS гарантує, що інформація про клієнта, наприклад номери кредитних
карток, зашифрована і не може бути перехоплена в розшифрованому вигляді.
Відвідувачі можуть переконатися, що сайт безпечний, подивившись на іконку зліва
від адресного рядка, захищені з'єднання позначаються іконкою замка.

## HTTP-запити

**Сервер** — це комп'ютер зі спеціальним програмним забезпеченням.

**Бекенд** — це програма, розташована на сервері, яка здатна обробити вхідні
HTTP-запити і має набір готових дій на певні запити.

![httpRequest](./img/11_ch/4.jpg)

**API (інтерфейс прикладного програмування)** — набір чітко визначених правил
зв'язку між різними програмними компонентами. Інтерфейс описує, що можна
попросити програму зробити і що буде в результаті.

**REST (representational state transfer)** — стиль бекенд-архітектури. Він
ґрунтується на наборі принципів, які описують, яким чином визначаються й
адресуються мережеві ресурси.

**REST API** — бекенд побудований за принципом REST. Слугує прошарком між
вебзастосунком і базою даних. Має стандартний інтерфейс для звернення до
ресурсів. Працює як вебсайт, ми посилаємо HTTP-запит із клієнта на сервер, а у
відповідь, замість HTML-сторінки, отримуємо дані в JSON-форматі.

Існують тисячі бекендів, і кожен з них унікальний. З іншого боку, REST API
побудовані за стандартною архітектурою. Отже, можна зрозуміти принцип їх роботи,
після чого все, що потрібно зробити — це ознайомитися з документацією того
бекенду, який необхідно використовувати.

### Шлях до ресурсу

Запити на бекенд повинні містити шлях до ресурсу, над яким виконується операція.
Доступні шляхи (ендпоінти, ресурси) описуються в документації бекенду.

**Ендпоінти (англ. endpoints) в контексті вебсервісів та API** — це конкретні
URL-адреси, через які можна отримати доступ до певних функцій або ресурсів
сервера. Вони служать точками входу для взаємодії між клієнтом і сервером,
дозволяючи отримувати, надсилати, оновлювати чи видаляти дані.

Давай розберемо це на прикладі JSONPlaceholder API. Це публічний REST API для
швидкого прототипування, який надає кілька різних колекцій уявних даних.

```js
<https://jsonplaceholder.typicode.com/users>
```

Такий шлях (ендпоінт) явно вказує на ресурс, навіть якщо ми його ніколи раніше
не бачили. Такий URL шлях є ієрархічним і описовим. Ми виконуємо запит на REST
API для отримання ресурсу `/users`.

Цей шлях складається з таких частин:

-   `https://jsonplaceholder.typicode.com` — це базовий URL, точка входу в API.
-   `/users` — ресурс, до якого звертаємося.

Візьми і встав цей шлях в адресний рядок браузера та перейди за ним.

Браузер виконає HTTP-запит, але замість HTML-файлу у відповіді прийде JSON з
даними, який відобразиться у вкладці як звичайний текст (див. схему).

![clientServer](./img/11_ch/5.jpg)

### Fetch API

Fetch API — це інтерфейс, який вбудований у браузер і доступний через об'єкт
`window`. Він надає набір властивостей і методів, які дозволяють відправляти,
отримувати та обробляти ресурси із сервера.

Метод `fetch()` надає сучасний інтерфейс для формування запитів до сервера і
побудований на промісах.

```js
fetch(url, options);
```

-   `url` — шлях до даних на бекенді, які необхідно отримати, створити або
    змінити. **Обов'язковий аргумент**.
-   `options` — об'єкт налаштувань запиту: метод, заголовки, тіло тощо.
    **Необов'язковий аргумент**.

`JSONPlaceholder API` — це вебсервіс, який містить декілька ресурсів
(користувачів, продуктів тощо).

У прикладі нижче будемо робити запит до нашого вебсервісу, щоб отримати колекцію
користувачів (ресурс `/users`).

```js
fetch('<https://jsonplaceholder.typicode.com/users>')
    .then(response => {
        // Response handling
    })
    .then(data => {
        // Data handling
    })
    .catch(error => {
        // Error handling
    });
```

Метод `fetch` повертає проміс, тому до результату його виклику додаємо ланцюжок
методів `then()` і `catch()` для обробки відповіді.

### Вкладка Network

В інструментах розробника на вкладці `Network` (укр. “Мережа”) відображаються
всі HTTP-запити, що виконуються на сторінці. Їх може бути корисно переглянути у
разі, коли розробнику потрібно перевірити деталі запиту на бекенд.

Як це зробити?

1. Вибери фільтр асинхронні HTTP/HTTPS-запити, зроблені за допомогою Fetch API
   або XMLHttpRequest, `XHR` або `Fetch/XHR` — так залишаться тільки асинхронні
   HTTP/HTTPS-запити, зроблені за допомогою Fetch API або XMLHttpRequest.
2. Після запуску скрипта з викликом методу `fetch`, через деякий час запит
   відобразиться у списку.
3. Вибери цей запит, щоб подивитися всю інформацію по ньому на підвкладках
   `Headers` (укр. “Заголовки”), `Preview` (укр. “Попередній перегляд”) і
   `Response` (укр. “Відповідь”).

![network](./img/11_ch/6.png)

## Коди відповідей

На запит клієнта сервер відправляє відповідь, яка містить код стану, щоб
інформувати клієнта про результат операції.

Код відповіді можна подивитися на вкладці `Network` у полі `Status Code`.

![network2](./img/11_ch/7.png)

Коди діляться на групи залежно від того, з якої цифри починається код помилки.

-   **1XX** — мають інформаційне призначення
-   **2XX** — коди успішного проведення операції
-   **3XX** — описують усе, що пов'язано з перенаправленням (redirect)
-   **4XX** — вказують на помилки з боку клієнта
-   **5XX** — вказують на помилки з боку сервера

Немає потреби пам'ятати всі коди з кожної групи, достатньо знати найпоширеніші.
Решту завжди можна подивитися в довіднику HTTP-кодів.

-   **200 (OK)** — стандартна відповідь для успішних HTTP-запитів.
-   **201 (Created)** — стандартна відповідь для HTTP-запиту, який привів до
    успішного створення ресурсу.
-   **400 (Bad Request)** — запит не може бути оброблений через неправильний
    синтаксис запиту або іншу помилку клієнта.
-   **401 (Unauthorized)** — для доступу до ресурсу вимагається авторизація.
-   **403 (Forbidden)** — у клієнта немає дозволу на доступ до цього ресурсу.
-   **404 (Not Found)** — у цей час ресурс не знайдений. Можливо, він був
    видалений або ще не існує.
-   **500 (Internal Server Error)** — загальна відповідь на непередбачений збій
    сервера, якщо відсутня конкретніша інформація.

### Перевірка відповіді

Значення промісу, який повертає метод `fetch()` — це об'єкт зі службовою
інформацією про стан відповіді сервера. Цей об’єкт є екземпляром класу
`Response`, який включає різні методи та властивості. Залежно від типу
отримуваного контенту, використовуються різні методи для перетворення тіла
відповіді у дані.

-   **json()** — парсить дані у JSON-форматі.
-   **text()** — парсить дані у простому текстовому форматі, наприклад `.csv`
    (табличні дані).
-   **blob()** — парсить дані, що описують файл, наприклад, зображення, аудіо
    або відео.

У прикладі нижче в першому методі `then()` виконується перевірка статусу
відповіді й перетворення даних у правильний формат (парсинг) у разі успішного
результату або явне створення помилки, щоб обробити невдалий HTTP-запит у методі
`catch()`.

```js
fetch('<https://jsonplaceholder.typicode.com/users>')
    .then(response => {
        if (!response.ok) {
            throw new Error(response.status);
        }
        return response.json();
    })
    .then(data => {
        // Data handling
        console.log(data);
    })
    .catch(error => {
        // Error handling
        console.log(error);
    });
```

Це необхідно для того, щоб `fetch()` правильно зреагував на статус код `404`,
який технічно не є помилкою, але для клієнта — це неуспішний результат.

### HTTP-методи

Виділяють кілька основних HTTP-методів для роботи з REST-сервісом.

-   **POST** — створити новий ресурс
-   **GET** — отримати набір ресурсів або один ресурс
-   **PUT** — оновити існуючий або створити новий ресурс
-   **PATCH** — оновити існуючий ресурс
-   **DELETE** — видалити ресурс

Поки що нас цікавить тільки метод `GET`.

Для того щоб вказати HTTP-метод, необхідно використовувати другий аргумент
методу `fetch`, а саме об'єкт налаштувань запиту. У його властивості `method`
необхідно передати рядок, що описує HTTP-метод.

```js
const options = {
    method: 'GET',
};

fetch('<https://jsonplaceholder.typicode.com/users>', options)
    .then(response => {
        if (!response.ok) {
            throw new Error(response.status);
        }
        return response.json();
    })
    .then(data => {
        // Data handling
    })
    .catch(error => {
        // Error handling
    });
```

-   Якщо тобі потрібно виконати GET-запит, то вказувати його в опціях `fetch` не
    потрібно, це метод запиту за замовчуванням.
-   Список можливих методів для кожного ресурсу описується в документації самого
    бекенда.

### HTTP-заголовки

Заголовки містять службову інформацію, що стосується запиту або відповіді.
Заголовок складається з імені та значення, наприклад:

-   заголовок `Accept` визначає тип контенту, який клієнт може прийняти та
    правильно обробити у відповіді від сервера ;
-   заголовок `Content-Type` описує тип ресурсу в запиті або відповіді, щоб
    отримувач знав, як правильно ці дані інтерпретувати.

```js
Accept: text/html
Content-Type: application/json
```

Заголовок складається з імені та значення. Значення заголовка — це MIME-тип (тип
контенту), який використовується для вказівки типу контенту запиту чи відповіді
і складається з типу і підтипу, розділених косою рискою (`/`).

Наприклад:

-   Текстовий файл, який містить HTML, буде описаний типом `text/html`.
-   Якщо текстовий файл містить CSS, він буде описаний як `text/css`.
-   Дані у форматі JSON будуть описані як `application/json`.

Якщо клієнт очікує `text/css`, а отримує `application/json`, він не зможе
розпізнати й коректно обробити вміст відповіді. Тому заголовки в запитах і
відповідях допомагають клієнту та серверу домовлятися про те, у якому форматі
буде передаватися інформація.

В інструментах розробника на вкладці `Network` можна побачити всі заголовки
відповіді в секції `Response Headers`, а заголовки запиту — в секції
`Request Headers`.

![responseHeaders](./img/11_ch/8.png)

Для складання заголовків запиту використовують літерал об'єкта з властивостями,
де кожен заголовок і його значення описується окремою властивістю. Усе це
описується в об'єкті налаштувань методу `fetch` у властивості `headers`.

```js
fetch('some-url', {
    headers: {
        'Content-Type': 'application/json',
        'X-Custom-Header': 'custom value',
    },
});
```

Наприклад, якщо ми хочемо явно вказати, що у відповіді від бекенда ми очікуємо
тільки JSON, то для цього додаємо заголовок `Accept` зі значенням
`application/json`.

```js
fetch('<https://jsonplaceholder.typicode.com/users>', {
    headers: {
        Accept: 'application/json',
    },
}).then(response => {
    // ...
});
```

Сучасні браузери додають багато заголовків за замовчуванням, залежно від
операції і тіла запиту, тому немає потреби явно вказувати стандартні заголовки.

Ось найпопулярніші з них:

-   `User-Agent`: Ідентифікує клієнтське програмне забезпечення, яке виконує
    запит
-   `Accept`: Вказує, які типи медіа клієнт може обробляти
-   `Content-Type`: Вказує тип контенту в тілі запиту або відповіді
-   `Authorization`: Використовується для передачі облікових даних для
    аутентифікації
-   `Cache-Control`: Директиви для керування кешуванням
-   `Host`: Доменне ім'я ресурсу, до якого виконується запит

### Кросдоменні запити

За замовчуванням HTTP-запит можна робити тільки в рамках поточного сайту. При
спробі запиту на інший домен, порт або протокол (тобто при спробі виконати
кросдоменний запит), браузер видає помилку. Це зроблено з міркувань безпеки, і
права доступу налаштовуються на бекенді. Якщо бекенд не підтримує кросдоменні
запити, фронтенд-розробник нічого не зможе з цим зробити у своєму коді.

Ця політика браузерів називається **CORS** і розшифровується як Cross-Origin
Resource Sharing, де Origin — це і є домен, порт або протокол. Дослівний
переклад звучить як «спільне використання ресурсів між різними джерелами».

На кожному запиті браузер сам додає HTTP-заголовок `Origin`, де вказує адресу
вебсторінки, яка хоче зробити HTTP-запит. Наприклад, якщо ми робимо fetch-запит
із вебсторінки `https://my-site.com/about` на `https://my-api.com/users`, то
заголовки будуть наступними:

```js
GET /users
Host: my-api.com
Origin: <https://my-site.com>
```

Сервер перевіряє заголовок `Origin` і, якщо він підтримує кросдоменні запити,
додає у відповідь спеціальний HTTP-заголовок `Access-Control-Allow-Origin`.

```js
# Private API
Access-Control-Allow-Origin: <https://my-site.com>

# Public API
Access-Control-Allow-Origin: *
```

Заголовок **`Access-Control-Allow-Origin`** визначає дозволені джерела, які
мають право отримувати відповідь на кросдоменні запити. Для приватного бекенду
значенням цього заголовку буде **`https://my-site.com`**, а для публічного —
спецсимвол `*`, що дозволяє доступ для всіх.

![fetch](./img/11_ch/9.jpg)

Отже, браузер — це певний посередник між JavaScript-кодом і бекендом. Він додає
кожному запиту заголовок Origin з правильним значенням і перевіряє наявність
заголовка `Access-Control-Allow-Origin` у відповіді. Якщо заголовок є і його
значення підходить, виконається оригінальний запит і JavaScript-код отримає його
результат, в іншому випадку буде помилка CORS.

## AJAX

**AJAX (Asynchronous JavaScript and XML)** — метод отримання або відправлення
даних з подальшим оновленням інтерфейсу за цими даними, без потреби
перезавантаження сторінки. Завдяки цьому зменшується час відгуку і вебсторінка
стає інтерактивнішою.

![ajax](./img/11_ch/10.jpg)

Цей процес можна розібрати на прикладі завантаження даних.

1. На вебсторінці відбувається подія (сторінка завантажується, натискається
   кнопка “**Показати більше**”, відправляється форма тощо).
2. На клієнті за допомогою JavaScript реакцією на цю подію буде виконуватися
   функція для роботи з сервером, де створюється і відправляється HTTP-запит.
3. Сервер отримує й обробляє HTTP-запит, відправляючи назад у відповіді дані у
   форматі JSON.
4. На клієнті за допомогою JavaScript відповідь від сервера обробляється,
   зчитуються дані і оновлюється інтерфейс.

Незважаючи на те, що в назві технології присутній XML, у сучасному інтернеті
його замінив JSON, а назву залишили як данину пам'яті. AJAX трактується як
будь-яке спілкування з сервером без перезавантаження сторінки.

### Оновлення інтерфейсу

Продовжимо працювати з `JSONPlaceholder API`, щоб отримати масив користувачів і
відтворити його в інтерфейсі.

Розгляньмо приклад, де є такий HTML:

```js
<button type="button" class="btn">Fetch users</button>
<ul class="user-list"></ul>
```

При кліку на кнопку **Fetch users** виконуємо HTTP-запит, використовуючи вже
знайомий нам метод `fetch`.

```js
const fetchUsersBtn = document.querySelector('.btn');

fetchUsersBtn.addEventListener('click', () => {
    fetch('<https://jsonplaceholder.typicode.com/users>')
        .then(response => {
            if (!response.ok) {
                throw new Error(response.status);
            }
            return response.json();
        })
        .then(users => {
            // Дані від бекенда
            console.log(users);
        })
        .catch(error => console.log(error));
});
```

У другому блоці `then` отримуємо доступ до даних відповіді від бекенда. Саме тут
можна використати ці дані й оновити інтерфейс, створити HTML-розмітку і додати
її в DOM у якийсь уже наявний елемент.

Для створення HTML-розмітки можна використовувати будь-який зручний спосіб,
наприклад `createElement` або `insertAdjacentHTML`. Розглянемо одну зі
стандартних технік.

-   Перебираємо масив об'єктів методом `map`
-   На кожній ітерації повертаємо HTML-розмітку для одного елемента колекції
-   Результуючий масив рядків зшиваємо в один рядок методом `join("")`
-   Додаємо рядок з HTML-розміткою в DOM методом `insertAdjacentHTML`

```js
const fetchUsersBtn = document.querySelector('.btn');
const userList = document.querySelector('.user-list');

fetchUsersBtn.addEventListener('click', () => {
    fetch('<https://jsonplaceholder.typicode.com/users>')
        .then(response => {
            if (!response.ok) {
                throw new Error(response.status);
            }
            return response.json();
        })
        .then(users => {
            const markup = users
                .map(user => {
                    return `<li>
	          <p><b>Name</b>: ${user.name}</p>
	          <p><b>Email</b>: ${user.email}</p>
	          <p><b>Company</b>: ${user.company.name}</p>
	        </li>`;
                })
                .join('');

            userList.insertAdjacentHTML('beforeend', markup);
        })
        .catch(error => console.log(error));
});
```

### Помилка новачка

Розберемо поширену помилку при роботі з асинхронним кодом — спробу
використовувати дані HTTP-запиту поза колбеком методу `then()` у синхронному
коді.

Новачок намагається записати «результат fetch» у зовнішню змінну і
використовувати її нижче в синхронному коді відразу після виклику методу
`fetch()`.

```js
let globalVariable; // undefined

// Виконуємо HTTP-запит
fetch('<https://jsonplaceholder.typicode.com/users>')
    .then(response => response.json())
    .then(users => {
        console.log('users inside then callback: ', users);

        // Асинхронно записуємо результат запиту в зовнішню змінну
        globalVariable = users;

        // Усередині колбека методу then усе добре
        console.log('globalVariable inside fetch callback: ', globalVariable);
    });

// Зовні колбека методу then у синхронному коді немає доступу до даних асинхронної відповіді бекенда
console.log('globalVariable outside fetch: ', globalVariable); // undefined
```

У нашому прикладі вище поза колбеком методу `then()` даних немає, оскільки
останній `console.log()` виконається раніше (синхронний код), ніж надійде
відповідь від сервера (асинхронний код). На момент виклику
`console.log("globalVariable outside fetch: ", globalVariable)` змінна
`globalVariable` ще має значення `undefined`. Значення промісу, що виконався,
доступне тільки в асинхронному коді, у нашому прикладі це в колбеку методу
`then()`.

> ! Тому дуже важливо пам'ятати, що спроба записати результат асинхронної
> операції в зовнішню змінну й використовувати його в синхронному коді —
> неефективний підхід. Замість цього краще використовувати методи `.then()` та
> `.catch()` для обробки результатів асинхронних операцій одразу після їх
> отримання.

### Параметри рядка запиту

Параметри запиту дозволяють вказати бекенду додаткові критерії, наприклад:

-   скільки елементів колекції ми хочемо отримати в запиті;
-   можливо, необхідно додати сортування за якоюсь властивістю об'єкта;
-   обмежити вибірку тощо.

Список параметрів запиту, їх назви і можливі значення залежать від бекенду і
описані в документації до нього.

Символ `?` вказує на початок параметрів запиту. Кожен параметр — це пара
`ім'я=значення`.

У рядку запиту параметри між собою розділяються символом `&`.

У документації JSONPlaceholder API описано можливі параметри рядка запиту:

-   `_limit`, який контролює кількість елементів у відповіді;
-   `_sort`, який відповідає за порядок сортування об'єктів у масиві.

```js
fetch('<https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name>');
```

GET-запит у прикладі вище поверне масив із семи користувачів (загалом їх 10),
відсортованих за ім'ям (поле `name`) за алфавітним порядком. Підкреслення в
іменах параметрів специфічні для цього бекенда, це не якийсь стандарт.

### Клас `URLSearchParams`

Параметрів може бути багато, і незручно складати з них один довгий рядок як для
читабельності, так і для його подальшого редагування.

Під час складання рядків параметрів, створюється екземпляр класу
`URLSearchParams` та ініціалізується об'єктом. Результатом буде спеціальний
об'єкт (ітератор) з методами, який у рядковому перетворенні повертає результат
виклику методу `toString()` — своє рядкове відображення.

```js
const searchParams = new URLSearchParams({
    _limit: 5,
    _sort: 'name',
});

console.log(searchParams.toString()); // "_limit=5&_sort=name"
const url = `https://jsonplaceholder.typicode.com/users?${searchParams}`;
console.log(url); // "<https://jsonplaceholder.typicode.com/users?_limit=5&_sort=name>"
```

У рядковому вигляді властивості об'єкта стануть параметрами та їх значеннями.
Параметри будуть розділені символом `&`. У разі інтерполяції значення в
шаблонних рядках відбувається його неявне перетворення в рядок, тому не потрібно
викликати метод `toString()` під час складання URL. Не забувай вказувати початок
рядка запиту символом `?`.

## Зміна даних

### CRUD

Для взаємодії з ресурсами бекенду використовується чотири операції:

1. створення (create),
2. читання (read),
3. оновлення (update),
4. видалення (delete). ![crud](./img/11_ch/11.jpg) Для кожної з них визначений
   стандартний HTTP-метод.

    - **POST** (Create) — створити новий ресурс.
    - **GET** (Read) — отримати набір ресурсів або один ресурс за
      ідентифікатором.
    - **PUT і PATCH** (Update) — оновити ресурс за ідентифікатором.
    - **DELETE** (Delete) — видалити ресурс за ідентифікатором.

Будемо робити запити до JSONPlaceholder API, який надає колекцію постів у
ресурсі `[/posts](<https://jsonplaceholder.typicode.com/posts>)`, представлених
об'єктами з властивостями `id`, `title` і `body`.

### Читання

HTTP-метод `GET` використовується для отримання існуючих даних.

Метод `fetch()` повинен відправити на сервер GET-запит без тіла. Бекенд після
отримання запиту обробить його і у відповіді поверне необхідні ресурси.

**Отримання всієї колекції**

Отримаємо масив усіх постів. З цією метою звертаємося до ресурсу `/posts`,
описаного в документації бекенду. Метод `fetch()` за замовчуванням робить
GET-запит, тому необов'язково перевизначати опції запиту.

```js
fetch('<https://jsonplaceholder.typicode.com/posts>')
    .then(response => {
        if (!response.ok) {
            throw new Error(response.status);
        }
        return response.json();
    })
    .then(posts => console.log(posts))
    .catch(error => console.log(error));
```

Отримання одного елемента

Отримаємо один пост за ідентифікатором (властивість `id`), додавши його до
ресурсу `/posts/:postId`.

Остання частина цього шляху (`:postId`) називається динамічний параметр і в
документації описується як `/ресурс/:параметр`. Динамічні параметри виділяються
двокрапкою `:` на початку. Вона використовується тільки для позначення, що це
динамічний параметр, у сам рядок запиту вона не потрапляє. Використання
динамічних параметрів сам ресурс (шлях до цілої колекції) не змінює, але
змінюється значення динамічного параметра для кожного її елемента.

```js
// Change this number to fetch different post
const postId = 1;

fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)
    .then(response => {
        if (!response.ok) {
            throw new Error(response.status);
        }
        return response.json();
    })
    .then(post => console.log(post))
    .catch(error => console.log(error));
```

### Створення

Метод `POST` використовується для додавання нового ресурсу.

Для того щоб передати дані на сервер, використовується тіло HTTP-запиту —
частина запиту, що містить дані, які передаються на сервер.

Тіло запиту може бути порожнім, якщо клієнт просто надсилає запит без додаткових
даних. Однак у POST-запитах тіло містить корисну інформацію, таку як дані форми,
JSON-об'єкти, файли або будь-які інші дані, які сервер повинен обробити.
Заголовок `Content-Type` вказує на тип даних у тілі запиту і допомагає серверу
правильно їх обробити.

Метод `fetch()` повинен відправити POST-запит на сервер, у тілі якого буде
об'єкт з полями `title` і `body`, ідентифікатор буде автоматично створений
бекендом. Результатом такого запиту буде об'єкт, доданий у базу даних бекенда.

```js
const postToAdd = {
    title: 'CRUD',
    body: 'CRUD is awesome!',
};

const options = {
    method: 'POST',
    body: JSON.stringify(postToAdd),
    headers: {
        'Content-Type': 'application/json; charset=UTF-8',
    },
};

fetch('<https://jsonplaceholder.typicode.com/posts>', options)
    .then(response => {
        if (!response.ok) {
            throw new Error(response.status);
        }
        return response.json();
    })
    .then(post => console.log(post))
    .catch(error => console.log(error));
```

У прикладі вище ми:

-   Робимо запит на створення поста, звертаючись до ресурсу `/posts`, але в
    об’єкті налаштування `options` методу `fetch()` змінюємо HTTP-метод на
    `POST`. Таким чином, бекенд знає, що потрібно не прочитати вже існуючий, а
    створити новий ресурс у цій колекції.
-   Тіло запиту повинно бути рядком, тому що протокол HTTP передає все як текст.
    При передачі складних типів даних, їх обов'язково необхідно привести до
    рядка методом `JSON.stringify()`.
-   Не забуваємо вказати заголовок `Content-Type`, який уточнює для бекенду тип
    переданих даних.

У відповідь, якщо все добре, отримаємо JSON представлення новоствореного поста,
але вже з доданим `id`. Ідентифікатор буде унікальним для кожного об'єкта.

```js
{
  "id": 101,
  "title": "CRUD",
  "body": "CRUD is awesome!"
}
```

### Оновлення

Методи `PUT` і `PATCH` використовуються для оновлення існуючих даних.

За HTTP-стандартом:

-   метод `PATCH` замінює в наявному ресурсі значення, які були передані в тілі
    запиту. Значення ресурсу, які не передавались, лишаться без змін;
-   метод `PUT` повністю замінює ресурс. Значення ресурсу, які не передавались,
    видаляються з ресурсу.

Який саме метод використовувати, буде написано в документації бекенду.

Метод `fetch()` повинен відправити на сервер запит, у тілі якого необхідно
вказати об'єкт із полями для зміни. Шлях вказує, у якій колекції і який елемент
потрібно оновити. Бекенд після отримання запиту обробить його і у відповіді
поверне оновлений ресурс.

```js
// Change value of id property to update different post
const postToUpdate = {
    id: 1,
    body: 'CRUD is really awesome!',
};

const options = {
    method: 'PATCH',
    body: JSON.stringify(postToUpdate),
    headers: {
        'Content-Type': 'application/json; charset=UTF-8',
    },
};

fetch(`https://jsonplaceholder.typicode.com/posts/${postToUpdate.id}`, options)
    .then(response => {
        if (!response.ok) {
            throw new Error(response.status);
        }
        return response.json();
    })
    .then(post => console.log(post))
    .catch(error => console.log('ERROR:', error));
```

У відповідь, якщо все добре, отримаємо оновлений об'єкт.

```js
{
  id: 1,
  title: "CRUD",
  body: "CRUD is really awesome!",
}
```

### Видалення

Метод `DELETE` використовується для видалення існуючих даних.

Метод `fetch()` повинен відправити на сервер DELETE-запит без тіла. Шлях вказує,
у якій колекції і який елемент ми хочемо видалити.

Бекенд після отримання запиту обробить його, видалить ресурс із колекції і у
відповіді поверне статус результату і видалений елемент.

```js
const postIdToDelete = 1;

fetch(`https://jsonplaceholder.typicode.com/posts/${postIdToDelete}`, {
    method: 'DELETE',
})
    .then(response => {
        if (!response.ok) {
            throw new Error(response.status);
        }
        return response.json();
    })
    .then(deletedPost => console.log(deletedPost))
    .catch(error => console.log('Error:', error));
```
